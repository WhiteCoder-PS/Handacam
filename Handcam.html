<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand-Controlled 3D Particle Morphing</title>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Mirror the canvas so movement feels natural */
        canvas {
            transform: scaleX(-1); 
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        button:hover {
            background: #ffffff;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #00ffcc;
            font-size: 14px;
            pointer-events: none;
        }

        /* Hide the raw video feed, we only want the 3D canvas */
        .input_video {
            display: none;
        }
        
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse { 0% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <div id="loading">Initializing AI & Graphics...</div>

    <div id="ui-container">
        <button onclick="setShape('sphere')">Sphere</button>
        <button onclick="setShape('heart')">Heart</button>
        <button onclick="setShape('saturn')">Saturn</button>
        <button onclick="setShape('flower')">Flower</button>
        <button onclick="setShape('helix')">Helix</button>
    </div>

    <div id="status">Waiting for hand...</div>

    <!-- Hidden Video Element for MediaPipe -->
    <video class="input_video"></video>

    <script>
        // --- 1. CONFIGURATION ---
        const PARTICLE_COUNT = 12000;
        const PARTICLE_SIZE = 0.15;
        let currentShape = 'sphere';
        
        // --- 2. THREE.JS SETUP ---
        const scene = new THREE.Scene();
        // Add a subtle fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 3. PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // Where particles want to go (Shape)
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        // Initialize particles randomly
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 20;
            targetPositions[i] = positions[i];
            colors[i] = 1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Create a glowing particle texture
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            map: sprite,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 4. SHAPE GENERATORS (MATH) ---
        function getSpherePoint(u, v, r) {
            const theta = u * Math.PI * 2;
            const phi = v * Math.PI;
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        function calculateShapes(type) {
            const tempPositions = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                
                // Normalized indices for distribution
                const u = Math.random();
                const v = Math.random();
                const idx = i / PARTICLE_COUNT;

                if (type === 'sphere') {
                    const p = getSpherePoint(u, v, 6);
                    x = p.x; y = p.y; z = p.z;
                } 
                else if (type === 'heart') {
                    // Parametric Heart Equation
                    const t = idx * Math.PI * 2; // slice
                    const r = Math.sqrt(v) * 20; // fill volume
                    // Using a specific heart formula for 3D
                    // We distribute randomly within the volume
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    
                    // Base heart shape
                    let hx = 16 * Math.pow(Math.sin(theta), 3);
                    let hy = 13 * Math.cos(theta) - 5 * Math.cos(2*theta) - 2 * Math.cos(3*theta) - Math.cos(4*theta);
                    let hz = (Math.random() - 0.5) * 5; // Thickness
                    
                    // Scale down
                    x = hx * 0.4;
                    y = hy * 0.4;
                    z = hz;
                } 
                else if (type === 'saturn') {
                    // 70% Planet, 30% Rings
                    if (i < PARTICLE_COUNT * 0.7) {
                        const p = getSpherePoint(u, v, 4);
                        x = p.x; y = p.y; z = p.z;
                    } else {
                        const theta = u * Math.PI * 2;
                        const r = 6 + v * 4; // Ring radius 6 to 10
                        x = r * Math.cos(theta);
                        z = r * Math.sin(theta); // Rings on XZ plane
                        y = (Math.random() - 0.5) * 0.5; // Thin vertically
                        
                        // Tilt the rings
                        const tilt = 0.4;
                        const ty = y * Math.cos(tilt) - z * Math.sin(tilt);
                        const tz = y * Math.sin(tilt) + z * Math.cos(tilt);
                        y = ty; z = tz;
                    }
                }
                else if (type === 'flower') {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    // Modulate radius with sine waves to create petals
                    const r = 5 + 2 * Math.sin(5 * theta) * Math.sin(5 * phi);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
                else if (type === 'helix') {
                    const t = idx * 10 * Math.PI;
                    const r = 3 + (idx * 3);
                    x = r * Math.cos(t);
                    y = (idx * 20) - 10;
                    z = r * Math.sin(t);
                }

                tempPositions.push(x, y, z);
            }
            return tempPositions;
        }

        function setShape(type) {
            currentShape = type;
            const newPos = calculateShapes(type);
            for(let i=0; i<PARTICLE_COUNT*3; i++) {
                targetPositions[i] = newPos[i];
            }
        }

        // Initialize with Sphere
        setShape('sphere');


        // --- 5. INTERACTION LOGIC (STATE) ---
        let handDetected = false;
        let handX = 0; // -1 to 1
        let handY = 0; // -1 to 1
        let pinchDistance = 1; // 0 (closed) to 1 (open)

        // --- 6. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            const positionsAttribute = particles.geometry.attributes.position;
            const colorsAttribute = particles.geometry.attributes.color;

            // Mapping pinch distance to visual properties
            // If pinched (distance close to 0): Hot/Red, Compact
            // If open (distance > 0.5): Cool/Blue, Expanded
            
            // Smoothed pinch value for animation
            const expansionFactor = 0.2 + (pinchDistance * 1.5); // 0.2 (tight) to 1.7 (exploded)
            
            // Dynamic Color Logic
            const rVal = 1 - pinchDistance; // Red when pinched
            const bVal = pinchDistance;     // Blue when open
            const gVal = 0.2;

            const array = positionsAttribute.array;
            const colorArray = colorsAttribute.array;

            // Global rotation of the entire system (adds life)
            particles.rotation.y += 0.002;
            particles.rotation.z += 0.001;

            // If hand is tracked, move system towards hand
            if (handDetected) {
                // Map normalized hand coordinates (-1 to 1) to world space
                const targetX = handX * 10; 
                const targetY = handY * 10;
                
                // Smoothly move the container
                particles.position.x += (targetX - particles.position.x) * 0.1;
                particles.position.y += (targetY - particles.position.y) * 0.1;
            } else {
                // Return to center if no hand
                particles.position.x += (0 - particles.position.x) * 0.05;
                particles.position.y += (0 - particles.position.y) * 0.05;
                pinchDistance += (1 - pinchDistance) * 0.05; // Default to open
            }

            // Update individual particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;

                // 1. Get Base Target (The Shape)
                let tx = targetPositions[i3];
                let ty = targetPositions[i3 + 1];
                let tz = targetPositions[i3 + 2];

                // 2. Apply Expansion/Explosion based on Pinch
                // We explode outward from the shape center (0,0,0)
                tx *= expansionFactor;
                ty *= expansionFactor;
                tz *= expansionFactor;

                // 3. Add Noise/Flow (make it look alive)
                // Use sine waves based on time and position
                tx += Math.sin(time + ty * 0.5) * 0.1;
                ty += Math.cos(time + tx * 0.5) * 0.1;

                // 4. Lerp Current Position to Target (Morphing Physics)
                array[i3]     += (tx - array[i3]) * 0.08;
                array[i3 + 1] += (ty - array[i3 + 1]) * 0.08;
                array[i3 + 2] += (tz - array[i3 + 2]) * 0.08;

                // 5. Update Colors
                // Interpolate between Hot and Cool based on pinch
                // We also vary color slightly per particle for texture
                colorArray[i3]     = rVal + (Math.random() * 0.1); // R
                colorArray[i3 + 1] = gVal * (pinchDistance > 0.5 ? 1 : 0.5); // G
                colorArray[i3 + 2] = bVal + (Math.random() * 0.2); // B
            }

            positionsAttribute.needsUpdate = true;
            colorsAttribute.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();

        // --- 7. MEDIAPIPE HAND TRACKING ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusElement = document.getElementById('status');
        const loadingElement = document.getElementById('loading');

        function onResults(results) {
            if (loadingElement.style.display !== 'none') {
                loadingElement.style.display = 'none';
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                statusElement.innerText = "Tracking Hand...";
                statusElement.style.color = "#00ff00";

                const landmarks = results.multiHandLandmarks[0];
                
                // Index Finger Tip (8)
                const indexTip = landmarks[8];
                // Thumb Tip (4)
                const thumbTip = landmarks[4];

                // Calculate center position (Input is 0.0 to 1.0)
                // We subtract 0.5 to center it at 0
                // X is inverted because of the mirror effect later
                const centerX = (indexTip.x + thumbTip.x) / 2;
                const centerY = (indexTip.y + thumbTip.y) / 2;
                
                // Map to -1 to 1 range
                handX = (centerX - 0.5) * 2; 
                handY = -(centerY - 0.5) * 2; // Invert Y for 3D world

                // Calculate Pinch Distance (Euclidean distance)
                const dx = indexTip.x - thumbTip.x;
                const dy = indexTip.y - thumbTip.y;
                const rawDist = Math.sqrt(dx*dx + dy*dy);
                
                // Normalize pinch: Approx range is 0.02 (touching) to 0.2 (open) usually
                // Map to 0 to 1
                let pd = (rawDist - 0.02) * 6;
                if(pd < 0) pd = 0;
                if(pd > 1) pd = 1;
                
                // Smooth the pinch value
                pinchDistance += (pd - pinchDistance) * 0.2;

            } else {
                handDetected = false;
                statusElement.innerText = "Show hand to control";
                statusElement.style.color = "#00ffcc";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraFeed.start().catch(err => {
            console.error(err);
            loadingElement.innerText = "Camera access denied or not found.";
        });

        // Window Resize Handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>